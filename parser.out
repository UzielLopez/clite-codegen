Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ID

Grammar

Rule 0     S' -> Addition
Rule 1     Addition -> Term
Rule 2     Addition -> Addition AddOp Term
Rule 3     Term -> Term MulOp Factor
Rule 4     Term -> Factor
Rule 5     AddOp -> +
Rule 6     AddOp -> -
Rule 7     MulOp -> *
Rule 8     MulOp -> /
Rule 9     MulOp -> %
Rule 10    Factor -> Primary
Rule 11    Primary -> INTLIT
Rule 12    Primary -> ( Addition )

Terminals, with rules where they appear

%                    : 9
(                    : 12
)                    : 12
*                    : 7
+                    : 5
-                    : 6
/                    : 8
ID                   : 
INTLIT               : 11
error                : 

Nonterminals, with rules where they appear

AddOp                : 2
Addition             : 2 12 0
Factor               : 3 4
MulOp                : 3
Primary              : 10
Term                 : 1 2 3

Parsing method: LALR

state 0

    (0) S' -> . Addition
    (1) Addition -> . Term
    (2) Addition -> . Addition AddOp Term
    (3) Term -> . Term MulOp Factor
    (4) Term -> . Factor
    (10) Factor -> . Primary
    (11) Primary -> . INTLIT
    (12) Primary -> . ( Addition )

    INTLIT          shift and go to state 5
    (               shift and go to state 6

    Addition                       shift and go to state 1
    Term                           shift and go to state 2
    Factor                         shift and go to state 3
    Primary                        shift and go to state 4

state 1

    (0) S' -> Addition .
    (2) Addition -> Addition . AddOp Term
    (5) AddOp -> . +
    (6) AddOp -> . -

    +               shift and go to state 8
    -               shift and go to state 9

    AddOp                          shift and go to state 7

state 2

    (1) Addition -> Term .
    (3) Term -> Term . MulOp Factor
    (7) MulOp -> . *
    (8) MulOp -> . /
    (9) MulOp -> . %

    +               reduce using rule 1 (Addition -> Term .)
    -               reduce using rule 1 (Addition -> Term .)
    $end            reduce using rule 1 (Addition -> Term .)
    )               reduce using rule 1 (Addition -> Term .)
    *               shift and go to state 11
    /               shift and go to state 12
    %               shift and go to state 13

    MulOp                          shift and go to state 10

state 3

    (4) Term -> Factor .

    *               reduce using rule 4 (Term -> Factor .)
    /               reduce using rule 4 (Term -> Factor .)
    %               reduce using rule 4 (Term -> Factor .)
    +               reduce using rule 4 (Term -> Factor .)
    -               reduce using rule 4 (Term -> Factor .)
    $end            reduce using rule 4 (Term -> Factor .)
    )               reduce using rule 4 (Term -> Factor .)


state 4

    (10) Factor -> Primary .

    *               reduce using rule 10 (Factor -> Primary .)
    /               reduce using rule 10 (Factor -> Primary .)
    %               reduce using rule 10 (Factor -> Primary .)
    +               reduce using rule 10 (Factor -> Primary .)
    -               reduce using rule 10 (Factor -> Primary .)
    $end            reduce using rule 10 (Factor -> Primary .)
    )               reduce using rule 10 (Factor -> Primary .)


state 5

    (11) Primary -> INTLIT .

    *               reduce using rule 11 (Primary -> INTLIT .)
    /               reduce using rule 11 (Primary -> INTLIT .)
    %               reduce using rule 11 (Primary -> INTLIT .)
    +               reduce using rule 11 (Primary -> INTLIT .)
    -               reduce using rule 11 (Primary -> INTLIT .)
    $end            reduce using rule 11 (Primary -> INTLIT .)
    )               reduce using rule 11 (Primary -> INTLIT .)


state 6

    (12) Primary -> ( . Addition )
    (1) Addition -> . Term
    (2) Addition -> . Addition AddOp Term
    (3) Term -> . Term MulOp Factor
    (4) Term -> . Factor
    (10) Factor -> . Primary
    (11) Primary -> . INTLIT
    (12) Primary -> . ( Addition )

    INTLIT          shift and go to state 5
    (               shift and go to state 6

    Addition                       shift and go to state 14
    Term                           shift and go to state 2
    Factor                         shift and go to state 3
    Primary                        shift and go to state 4

state 7

    (2) Addition -> Addition AddOp . Term
    (3) Term -> . Term MulOp Factor
    (4) Term -> . Factor
    (10) Factor -> . Primary
    (11) Primary -> . INTLIT
    (12) Primary -> . ( Addition )

    INTLIT          shift and go to state 5
    (               shift and go to state 6

    Term                           shift and go to state 15
    Factor                         shift and go to state 3
    Primary                        shift and go to state 4

state 8

    (5) AddOp -> + .

    INTLIT          reduce using rule 5 (AddOp -> + .)
    (               reduce using rule 5 (AddOp -> + .)


state 9

    (6) AddOp -> - .

    INTLIT          reduce using rule 6 (AddOp -> - .)
    (               reduce using rule 6 (AddOp -> - .)


state 10

    (3) Term -> Term MulOp . Factor
    (10) Factor -> . Primary
    (11) Primary -> . INTLIT
    (12) Primary -> . ( Addition )

    INTLIT          shift and go to state 5
    (               shift and go to state 6

    Factor                         shift and go to state 16
    Primary                        shift and go to state 4

state 11

    (7) MulOp -> * .

    INTLIT          reduce using rule 7 (MulOp -> * .)
    (               reduce using rule 7 (MulOp -> * .)


state 12

    (8) MulOp -> / .

    INTLIT          reduce using rule 8 (MulOp -> / .)
    (               reduce using rule 8 (MulOp -> / .)


state 13

    (9) MulOp -> % .

    INTLIT          reduce using rule 9 (MulOp -> % .)
    (               reduce using rule 9 (MulOp -> % .)


state 14

    (12) Primary -> ( Addition . )
    (2) Addition -> Addition . AddOp Term
    (5) AddOp -> . +
    (6) AddOp -> . -

    )               shift and go to state 17
    +               shift and go to state 8
    -               shift and go to state 9

    AddOp                          shift and go to state 7

state 15

    (2) Addition -> Addition AddOp Term .
    (3) Term -> Term . MulOp Factor
    (7) MulOp -> . *
    (8) MulOp -> . /
    (9) MulOp -> . %

    +               reduce using rule 2 (Addition -> Addition AddOp Term .)
    -               reduce using rule 2 (Addition -> Addition AddOp Term .)
    $end            reduce using rule 2 (Addition -> Addition AddOp Term .)
    )               reduce using rule 2 (Addition -> Addition AddOp Term .)
    *               shift and go to state 11
    /               shift and go to state 12
    %               shift and go to state 13

    MulOp                          shift and go to state 10

state 16

    (3) Term -> Term MulOp Factor .

    *               reduce using rule 3 (Term -> Term MulOp Factor .)
    /               reduce using rule 3 (Term -> Term MulOp Factor .)
    %               reduce using rule 3 (Term -> Term MulOp Factor .)
    +               reduce using rule 3 (Term -> Term MulOp Factor .)
    -               reduce using rule 3 (Term -> Term MulOp Factor .)
    $end            reduce using rule 3 (Term -> Term MulOp Factor .)
    )               reduce using rule 3 (Term -> Term MulOp Factor .)


state 17

    (12) Primary -> ( Addition ) .

    *               reduce using rule 12 (Primary -> ( Addition ) .)
    /               reduce using rule 12 (Primary -> ( Addition ) .)
    %               reduce using rule 12 (Primary -> ( Addition ) .)
    +               reduce using rule 12 (Primary -> ( Addition ) .)
    -               reduce using rule 12 (Primary -> ( Addition ) .)
    $end            reduce using rule 12 (Primary -> ( Addition ) .)
    )               reduce using rule 12 (Primary -> ( Addition ) .)

