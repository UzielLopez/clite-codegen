Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    RETURN

Grammar

Rule 0     S' -> Program
Rule 1     Program -> INT MAIN ( ) { Declarations Statements }
Rule 2     empty -> <empty>
Rule 3     Declarations -> Declaration Declarations
Rule 4     Declarations -> empty
Rule 5     Declaration -> Type ID ;
Rule 6     Type -> INT
Rule 7     Type -> BOOL
Rule 8     Type -> FLOAT
Rule 9     Type -> CHAR
Rule 10    Statements -> Statement Statements
Rule 11    Statements -> empty
Rule 12    Statement -> ;
Rule 13    Statement -> Block
Rule 14    Statement -> Assignment
Rule 15    Statement -> IfStatement
Rule 16    Statement -> WhileStatement
Rule 17    Block -> { Statements }
Rule 18    Assignment -> ID = Expression ;
Rule 19    IfStatement -> IF ( Expression ) Statement
Rule 20    IfStatement -> IF ( Expression ) Statement ELSE Statement
Rule 21    WhileStatement -> WHILE ( Expression ) Statement
Rule 22    Expression -> Conjunction
Rule 23    Expression -> Expression OR Conjunction
Rule 24    Conjunction -> Equality
Rule 25    Conjunction -> Conjunction AND Equality
Rule 26    Equality -> Relation
Rule 27    Equality -> Relation EquOp Relation
Rule 28    EquOp -> EQ
Rule 29    EquOp -> NEQ
Rule 30    Relation -> Addition
Rule 31    Relation -> Addition RelOp Addition
Rule 32    RelOp -> <
Rule 33    RelOp -> LE
Rule 34    RelOp -> >
Rule 35    RelOp -> GE
Rule 36    Addition -> Term
Rule 37    Addition -> Addition AddOp Term
Rule 38    AddOp -> +
Rule 39    AddOp -> -
Rule 40    Term -> Factor
Rule 41    Term -> Term MulOp Factor
Rule 42    MulOp -> *
Rule 43    MulOp -> /
Rule 44    MulOp -> %
Rule 45    Factor -> Primary
Rule 46    Factor -> UnaryOp Primary
Rule 47    UnaryOp -> -
Rule 48    UnaryOp -> !
Rule 49    Primary -> FLOATLIT
Rule 50    Primary -> INTLIT
Rule 51    Primary -> ID
Rule 52    Primary -> ( Expression )

Terminals, with rules where they appear

!                    : 48
%                    : 44
(                    : 1 19 20 21 52
)                    : 1 19 20 21 52
*                    : 42
+                    : 38
-                    : 39 47
/                    : 43
;                    : 5 12 18
<                    : 32
=                    : 18
>                    : 34
AND                  : 25
BOOL                 : 7
CHAR                 : 9
ELSE                 : 20
EQ                   : 28
FLOAT                : 8
FLOATLIT             : 49
GE                   : 35
ID                   : 5 18 51
IF                   : 19 20
INT                  : 1 6
INTLIT               : 50
LE                   : 33
MAIN                 : 1
NEQ                  : 29
OR                   : 23
RETURN               : 
WHILE                : 21
error                : 
{                    : 1 17
}                    : 1 17

Nonterminals, with rules where they appear

AddOp                : 37
Addition             : 30 31 31 37
Assignment           : 14
Block                : 13
Conjunction          : 22 23 25
Declaration          : 3
Declarations         : 1 3
EquOp                : 27
Equality             : 24 25
Expression           : 18 19 20 21 23 52
Factor               : 40 41
IfStatement          : 15
MulOp                : 41
Primary              : 45 46
Program              : 0
RelOp                : 31
Relation             : 26 27 27
Statement            : 10 19 20 20 21
Statements           : 1 10 17
Term                 : 36 37 41
Type                 : 5
UnaryOp              : 46
WhileStatement       : 16
empty                : 4 11

Parsing method: LALR

state 0

    (0) S' -> . Program
    (1) Program -> . INT MAIN ( ) { Declarations Statements }

    INT             shift and go to state 2

    Program                        shift and go to state 1

state 1

    (0) S' -> Program .



state 2

    (1) Program -> INT . MAIN ( ) { Declarations Statements }

    MAIN            shift and go to state 3


state 3

    (1) Program -> INT MAIN . ( ) { Declarations Statements }

    (               shift and go to state 4


state 4

    (1) Program -> INT MAIN ( . ) { Declarations Statements }

    )               shift and go to state 5


state 5

    (1) Program -> INT MAIN ( ) . { Declarations Statements }

    {               shift and go to state 6


state 6

    (1) Program -> INT MAIN ( ) { . Declarations Statements }
    (3) Declarations -> . Declaration Declarations
    (4) Declarations -> . empty
    (5) Declaration -> . Type ID ;
    (2) empty -> .
    (6) Type -> . INT
    (7) Type -> . BOOL
    (8) Type -> . FLOAT
    (9) Type -> . CHAR

    ;               reduce using rule 2 (empty -> .)
    {               reduce using rule 2 (empty -> .)
    ID              reduce using rule 2 (empty -> .)
    IF              reduce using rule 2 (empty -> .)
    WHILE           reduce using rule 2 (empty -> .)
    }               reduce using rule 2 (empty -> .)
    INT             shift and go to state 7
    BOOL            shift and go to state 12
    FLOAT           shift and go to state 13
    CHAR            shift and go to state 14

    Declarations                   shift and go to state 8
    Declaration                    shift and go to state 9
    empty                          shift and go to state 10
    Type                           shift and go to state 11

state 7

    (6) Type -> INT .

    ID              reduce using rule 6 (Type -> INT .)


state 8

    (1) Program -> INT MAIN ( ) { Declarations . Statements }
    (10) Statements -> . Statement Statements
    (11) Statements -> . empty
    (12) Statement -> . ;
    (13) Statement -> . Block
    (14) Statement -> . Assignment
    (15) Statement -> . IfStatement
    (16) Statement -> . WhileStatement
    (2) empty -> .
    (17) Block -> . { Statements }
    (18) Assignment -> . ID = Expression ;
    (19) IfStatement -> . IF ( Expression ) Statement
    (20) IfStatement -> . IF ( Expression ) Statement ELSE Statement
    (21) WhileStatement -> . WHILE ( Expression ) Statement

    ;               shift and go to state 19
    }               reduce using rule 2 (empty -> .)
    {               shift and go to state 15
    ID              shift and go to state 24
    IF              shift and go to state 25
    WHILE           shift and go to state 26

    Statements                     shift and go to state 16
    Statement                      shift and go to state 17
    empty                          shift and go to state 18
    Block                          shift and go to state 20
    Assignment                     shift and go to state 21
    IfStatement                    shift and go to state 22
    WhileStatement                 shift and go to state 23

state 9

    (3) Declarations -> Declaration . Declarations
    (3) Declarations -> . Declaration Declarations
    (4) Declarations -> . empty
    (5) Declaration -> . Type ID ;
    (2) empty -> .
    (6) Type -> . INT
    (7) Type -> . BOOL
    (8) Type -> . FLOAT
    (9) Type -> . CHAR

    ;               reduce using rule 2 (empty -> .)
    {               reduce using rule 2 (empty -> .)
    ID              reduce using rule 2 (empty -> .)
    IF              reduce using rule 2 (empty -> .)
    WHILE           reduce using rule 2 (empty -> .)
    }               reduce using rule 2 (empty -> .)
    INT             shift and go to state 7
    BOOL            shift and go to state 12
    FLOAT           shift and go to state 13
    CHAR            shift and go to state 14

    Declaration                    shift and go to state 9
    Declarations                   shift and go to state 27
    empty                          shift and go to state 10
    Type                           shift and go to state 11

state 10

    (4) Declarations -> empty .

    ;               reduce using rule 4 (Declarations -> empty .)
    {               reduce using rule 4 (Declarations -> empty .)
    ID              reduce using rule 4 (Declarations -> empty .)
    IF              reduce using rule 4 (Declarations -> empty .)
    WHILE           reduce using rule 4 (Declarations -> empty .)
    }               reduce using rule 4 (Declarations -> empty .)


state 11

    (5) Declaration -> Type . ID ;

    ID              shift and go to state 28


state 12

    (7) Type -> BOOL .

    ID              reduce using rule 7 (Type -> BOOL .)


state 13

    (8) Type -> FLOAT .

    ID              reduce using rule 8 (Type -> FLOAT .)


state 14

    (9) Type -> CHAR .

    ID              reduce using rule 9 (Type -> CHAR .)


state 15

    (17) Block -> { . Statements }
    (10) Statements -> . Statement Statements
    (11) Statements -> . empty
    (12) Statement -> . ;
    (13) Statement -> . Block
    (14) Statement -> . Assignment
    (15) Statement -> . IfStatement
    (16) Statement -> . WhileStatement
    (2) empty -> .
    (17) Block -> . { Statements }
    (18) Assignment -> . ID = Expression ;
    (19) IfStatement -> . IF ( Expression ) Statement
    (20) IfStatement -> . IF ( Expression ) Statement ELSE Statement
    (21) WhileStatement -> . WHILE ( Expression ) Statement

    ;               shift and go to state 19
    }               reduce using rule 2 (empty -> .)
    {               shift and go to state 15
    ID              shift and go to state 24
    IF              shift and go to state 25
    WHILE           shift and go to state 26

    Statements                     shift and go to state 29
    Statement                      shift and go to state 17
    empty                          shift and go to state 18
    Block                          shift and go to state 20
    Assignment                     shift and go to state 21
    IfStatement                    shift and go to state 22
    WhileStatement                 shift and go to state 23

state 16

    (1) Program -> INT MAIN ( ) { Declarations Statements . }

    }               shift and go to state 30


state 17

    (10) Statements -> Statement . Statements
    (10) Statements -> . Statement Statements
    (11) Statements -> . empty
    (12) Statement -> . ;
    (13) Statement -> . Block
    (14) Statement -> . Assignment
    (15) Statement -> . IfStatement
    (16) Statement -> . WhileStatement
    (2) empty -> .
    (17) Block -> . { Statements }
    (18) Assignment -> . ID = Expression ;
    (19) IfStatement -> . IF ( Expression ) Statement
    (20) IfStatement -> . IF ( Expression ) Statement ELSE Statement
    (21) WhileStatement -> . WHILE ( Expression ) Statement

    ;               shift and go to state 19
    }               reduce using rule 2 (empty -> .)
    {               shift and go to state 15
    ID              shift and go to state 24
    IF              shift and go to state 25
    WHILE           shift and go to state 26

    Statement                      shift and go to state 17
    Statements                     shift and go to state 31
    empty                          shift and go to state 18
    Block                          shift and go to state 20
    Assignment                     shift and go to state 21
    IfStatement                    shift and go to state 22
    WhileStatement                 shift and go to state 23

state 18

    (11) Statements -> empty .

    }               reduce using rule 11 (Statements -> empty .)


state 19

    (12) Statement -> ; .

    ;               reduce using rule 12 (Statement -> ; .)
    {               reduce using rule 12 (Statement -> ; .)
    ID              reduce using rule 12 (Statement -> ; .)
    IF              reduce using rule 12 (Statement -> ; .)
    WHILE           reduce using rule 12 (Statement -> ; .)
    }               reduce using rule 12 (Statement -> ; .)
    ELSE            reduce using rule 12 (Statement -> ; .)


state 20

    (13) Statement -> Block .

    ;               reduce using rule 13 (Statement -> Block .)
    {               reduce using rule 13 (Statement -> Block .)
    ID              reduce using rule 13 (Statement -> Block .)
    IF              reduce using rule 13 (Statement -> Block .)
    WHILE           reduce using rule 13 (Statement -> Block .)
    }               reduce using rule 13 (Statement -> Block .)
    ELSE            reduce using rule 13 (Statement -> Block .)


state 21

    (14) Statement -> Assignment .

    ;               reduce using rule 14 (Statement -> Assignment .)
    {               reduce using rule 14 (Statement -> Assignment .)
    ID              reduce using rule 14 (Statement -> Assignment .)
    IF              reduce using rule 14 (Statement -> Assignment .)
    WHILE           reduce using rule 14 (Statement -> Assignment .)
    }               reduce using rule 14 (Statement -> Assignment .)
    ELSE            reduce using rule 14 (Statement -> Assignment .)


state 22

    (15) Statement -> IfStatement .

    ;               reduce using rule 15 (Statement -> IfStatement .)
    {               reduce using rule 15 (Statement -> IfStatement .)
    ID              reduce using rule 15 (Statement -> IfStatement .)
    IF              reduce using rule 15 (Statement -> IfStatement .)
    WHILE           reduce using rule 15 (Statement -> IfStatement .)
    }               reduce using rule 15 (Statement -> IfStatement .)
    ELSE            reduce using rule 15 (Statement -> IfStatement .)


state 23

    (16) Statement -> WhileStatement .

    ;               reduce using rule 16 (Statement -> WhileStatement .)
    {               reduce using rule 16 (Statement -> WhileStatement .)
    ID              reduce using rule 16 (Statement -> WhileStatement .)
    IF              reduce using rule 16 (Statement -> WhileStatement .)
    WHILE           reduce using rule 16 (Statement -> WhileStatement .)
    }               reduce using rule 16 (Statement -> WhileStatement .)
    ELSE            reduce using rule 16 (Statement -> WhileStatement .)


state 24

    (18) Assignment -> ID . = Expression ;

    =               shift and go to state 32


state 25

    (19) IfStatement -> IF . ( Expression ) Statement
    (20) IfStatement -> IF . ( Expression ) Statement ELSE Statement

    (               shift and go to state 33


state 26

    (21) WhileStatement -> WHILE . ( Expression ) Statement

    (               shift and go to state 34


state 27

    (3) Declarations -> Declaration Declarations .

    ;               reduce using rule 3 (Declarations -> Declaration Declarations .)
    {               reduce using rule 3 (Declarations -> Declaration Declarations .)
    ID              reduce using rule 3 (Declarations -> Declaration Declarations .)
    IF              reduce using rule 3 (Declarations -> Declaration Declarations .)
    WHILE           reduce using rule 3 (Declarations -> Declaration Declarations .)
    }               reduce using rule 3 (Declarations -> Declaration Declarations .)


state 28

    (5) Declaration -> Type ID . ;

    ;               shift and go to state 35


state 29

    (17) Block -> { Statements . }

    }               shift and go to state 36


state 30

    (1) Program -> INT MAIN ( ) { Declarations Statements } .

    $end            reduce using rule 1 (Program -> INT MAIN ( ) { Declarations Statements } .)


state 31

    (10) Statements -> Statement Statements .

    }               reduce using rule 10 (Statements -> Statement Statements .)


state 32

    (18) Assignment -> ID = . Expression ;
    (22) Expression -> . Conjunction
    (23) Expression -> . Expression OR Conjunction
    (24) Conjunction -> . Equality
    (25) Conjunction -> . Conjunction AND Equality
    (26) Equality -> . Relation
    (27) Equality -> . Relation EquOp Relation
    (30) Relation -> . Addition
    (31) Relation -> . Addition RelOp Addition
    (36) Addition -> . Term
    (37) Addition -> . Addition AddOp Term
    (40) Term -> . Factor
    (41) Term -> . Term MulOp Factor
    (45) Factor -> . Primary
    (46) Factor -> . UnaryOp Primary
    (49) Primary -> . FLOATLIT
    (50) Primary -> . INTLIT
    (51) Primary -> . ID
    (52) Primary -> . ( Expression )
    (47) UnaryOp -> . -
    (48) UnaryOp -> . !

    FLOATLIT        shift and go to state 47
    INTLIT          shift and go to state 48
    ID              shift and go to state 37
    (               shift and go to state 49
    -               shift and go to state 50
    !               shift and go to state 51

    Expression                     shift and go to state 38
    Conjunction                    shift and go to state 39
    Equality                       shift and go to state 40
    Relation                       shift and go to state 41
    Addition                       shift and go to state 42
    Term                           shift and go to state 43
    Factor                         shift and go to state 44
    Primary                        shift and go to state 45
    UnaryOp                        shift and go to state 46

state 33

    (19) IfStatement -> IF ( . Expression ) Statement
    (20) IfStatement -> IF ( . Expression ) Statement ELSE Statement
    (22) Expression -> . Conjunction
    (23) Expression -> . Expression OR Conjunction
    (24) Conjunction -> . Equality
    (25) Conjunction -> . Conjunction AND Equality
    (26) Equality -> . Relation
    (27) Equality -> . Relation EquOp Relation
    (30) Relation -> . Addition
    (31) Relation -> . Addition RelOp Addition
    (36) Addition -> . Term
    (37) Addition -> . Addition AddOp Term
    (40) Term -> . Factor
    (41) Term -> . Term MulOp Factor
    (45) Factor -> . Primary
    (46) Factor -> . UnaryOp Primary
    (49) Primary -> . FLOATLIT
    (50) Primary -> . INTLIT
    (51) Primary -> . ID
    (52) Primary -> . ( Expression )
    (47) UnaryOp -> . -
    (48) UnaryOp -> . !

    FLOATLIT        shift and go to state 47
    INTLIT          shift and go to state 48
    ID              shift and go to state 37
    (               shift and go to state 49
    -               shift and go to state 50
    !               shift and go to state 51

    Expression                     shift and go to state 52
    Conjunction                    shift and go to state 39
    Equality                       shift and go to state 40
    Relation                       shift and go to state 41
    Addition                       shift and go to state 42
    Term                           shift and go to state 43
    Factor                         shift and go to state 44
    Primary                        shift and go to state 45
    UnaryOp                        shift and go to state 46

state 34

    (21) WhileStatement -> WHILE ( . Expression ) Statement
    (22) Expression -> . Conjunction
    (23) Expression -> . Expression OR Conjunction
    (24) Conjunction -> . Equality
    (25) Conjunction -> . Conjunction AND Equality
    (26) Equality -> . Relation
    (27) Equality -> . Relation EquOp Relation
    (30) Relation -> . Addition
    (31) Relation -> . Addition RelOp Addition
    (36) Addition -> . Term
    (37) Addition -> . Addition AddOp Term
    (40) Term -> . Factor
    (41) Term -> . Term MulOp Factor
    (45) Factor -> . Primary
    (46) Factor -> . UnaryOp Primary
    (49) Primary -> . FLOATLIT
    (50) Primary -> . INTLIT
    (51) Primary -> . ID
    (52) Primary -> . ( Expression )
    (47) UnaryOp -> . -
    (48) UnaryOp -> . !

    FLOATLIT        shift and go to state 47
    INTLIT          shift and go to state 48
    ID              shift and go to state 37
    (               shift and go to state 49
    -               shift and go to state 50
    !               shift and go to state 51

    Expression                     shift and go to state 53
    Conjunction                    shift and go to state 39
    Equality                       shift and go to state 40
    Relation                       shift and go to state 41
    Addition                       shift and go to state 42
    Term                           shift and go to state 43
    Factor                         shift and go to state 44
    Primary                        shift and go to state 45
    UnaryOp                        shift and go to state 46

state 35

    (5) Declaration -> Type ID ; .

    INT             reduce using rule 5 (Declaration -> Type ID ; .)
    BOOL            reduce using rule 5 (Declaration -> Type ID ; .)
    FLOAT           reduce using rule 5 (Declaration -> Type ID ; .)
    CHAR            reduce using rule 5 (Declaration -> Type ID ; .)
    ;               reduce using rule 5 (Declaration -> Type ID ; .)
    {               reduce using rule 5 (Declaration -> Type ID ; .)
    ID              reduce using rule 5 (Declaration -> Type ID ; .)
    IF              reduce using rule 5 (Declaration -> Type ID ; .)
    WHILE           reduce using rule 5 (Declaration -> Type ID ; .)
    }               reduce using rule 5 (Declaration -> Type ID ; .)


state 36

    (17) Block -> { Statements } .

    ;               reduce using rule 17 (Block -> { Statements } .)
    {               reduce using rule 17 (Block -> { Statements } .)
    ID              reduce using rule 17 (Block -> { Statements } .)
    IF              reduce using rule 17 (Block -> { Statements } .)
    WHILE           reduce using rule 17 (Block -> { Statements } .)
    }               reduce using rule 17 (Block -> { Statements } .)
    ELSE            reduce using rule 17 (Block -> { Statements } .)


state 37

    (51) Primary -> ID .

    *               reduce using rule 51 (Primary -> ID .)
    /               reduce using rule 51 (Primary -> ID .)
    %               reduce using rule 51 (Primary -> ID .)
    <               reduce using rule 51 (Primary -> ID .)
    LE              reduce using rule 51 (Primary -> ID .)
    >               reduce using rule 51 (Primary -> ID .)
    GE              reduce using rule 51 (Primary -> ID .)
    +               reduce using rule 51 (Primary -> ID .)
    -               reduce using rule 51 (Primary -> ID .)
    EQ              reduce using rule 51 (Primary -> ID .)
    NEQ             reduce using rule 51 (Primary -> ID .)
    AND             reduce using rule 51 (Primary -> ID .)
    ;               reduce using rule 51 (Primary -> ID .)
    OR              reduce using rule 51 (Primary -> ID .)
    )               reduce using rule 51 (Primary -> ID .)


state 38

    (18) Assignment -> ID = Expression . ;
    (23) Expression -> Expression . OR Conjunction

    ;               shift and go to state 54
    OR              shift and go to state 55


state 39

    (22) Expression -> Conjunction .
    (25) Conjunction -> Conjunction . AND Equality

    ;               reduce using rule 22 (Expression -> Conjunction .)
    OR              reduce using rule 22 (Expression -> Conjunction .)
    )               reduce using rule 22 (Expression -> Conjunction .)
    AND             shift and go to state 56


state 40

    (24) Conjunction -> Equality .

    AND             reduce using rule 24 (Conjunction -> Equality .)
    ;               reduce using rule 24 (Conjunction -> Equality .)
    OR              reduce using rule 24 (Conjunction -> Equality .)
    )               reduce using rule 24 (Conjunction -> Equality .)


state 41

    (26) Equality -> Relation .
    (27) Equality -> Relation . EquOp Relation
    (28) EquOp -> . EQ
    (29) EquOp -> . NEQ

    AND             reduce using rule 26 (Equality -> Relation .)
    ;               reduce using rule 26 (Equality -> Relation .)
    OR              reduce using rule 26 (Equality -> Relation .)
    )               reduce using rule 26 (Equality -> Relation .)
    EQ              shift and go to state 58
    NEQ             shift and go to state 59

    EquOp                          shift and go to state 57

state 42

    (30) Relation -> Addition .
    (31) Relation -> Addition . RelOp Addition
    (37) Addition -> Addition . AddOp Term
    (32) RelOp -> . <
    (33) RelOp -> . LE
    (34) RelOp -> . >
    (35) RelOp -> . GE
    (38) AddOp -> . +
    (39) AddOp -> . -

    EQ              reduce using rule 30 (Relation -> Addition .)
    NEQ             reduce using rule 30 (Relation -> Addition .)
    AND             reduce using rule 30 (Relation -> Addition .)
    ;               reduce using rule 30 (Relation -> Addition .)
    OR              reduce using rule 30 (Relation -> Addition .)
    )               reduce using rule 30 (Relation -> Addition .)
    <               shift and go to state 62
    LE              shift and go to state 63
    >               shift and go to state 64
    GE              shift and go to state 65
    +               shift and go to state 66
    -               shift and go to state 67

    RelOp                          shift and go to state 60
    AddOp                          shift and go to state 61

state 43

    (36) Addition -> Term .
    (41) Term -> Term . MulOp Factor
    (42) MulOp -> . *
    (43) MulOp -> . /
    (44) MulOp -> . %

    <               reduce using rule 36 (Addition -> Term .)
    LE              reduce using rule 36 (Addition -> Term .)
    >               reduce using rule 36 (Addition -> Term .)
    GE              reduce using rule 36 (Addition -> Term .)
    +               reduce using rule 36 (Addition -> Term .)
    -               reduce using rule 36 (Addition -> Term .)
    EQ              reduce using rule 36 (Addition -> Term .)
    NEQ             reduce using rule 36 (Addition -> Term .)
    AND             reduce using rule 36 (Addition -> Term .)
    ;               reduce using rule 36 (Addition -> Term .)
    OR              reduce using rule 36 (Addition -> Term .)
    )               reduce using rule 36 (Addition -> Term .)
    *               shift and go to state 69
    /               shift and go to state 70
    %               shift and go to state 71

    MulOp                          shift and go to state 68

state 44

    (40) Term -> Factor .

    *               reduce using rule 40 (Term -> Factor .)
    /               reduce using rule 40 (Term -> Factor .)
    %               reduce using rule 40 (Term -> Factor .)
    <               reduce using rule 40 (Term -> Factor .)
    LE              reduce using rule 40 (Term -> Factor .)
    >               reduce using rule 40 (Term -> Factor .)
    GE              reduce using rule 40 (Term -> Factor .)
    +               reduce using rule 40 (Term -> Factor .)
    -               reduce using rule 40 (Term -> Factor .)
    EQ              reduce using rule 40 (Term -> Factor .)
    NEQ             reduce using rule 40 (Term -> Factor .)
    AND             reduce using rule 40 (Term -> Factor .)
    ;               reduce using rule 40 (Term -> Factor .)
    OR              reduce using rule 40 (Term -> Factor .)
    )               reduce using rule 40 (Term -> Factor .)


state 45

    (45) Factor -> Primary .

    *               reduce using rule 45 (Factor -> Primary .)
    /               reduce using rule 45 (Factor -> Primary .)
    %               reduce using rule 45 (Factor -> Primary .)
    <               reduce using rule 45 (Factor -> Primary .)
    LE              reduce using rule 45 (Factor -> Primary .)
    >               reduce using rule 45 (Factor -> Primary .)
    GE              reduce using rule 45 (Factor -> Primary .)
    +               reduce using rule 45 (Factor -> Primary .)
    -               reduce using rule 45 (Factor -> Primary .)
    EQ              reduce using rule 45 (Factor -> Primary .)
    NEQ             reduce using rule 45 (Factor -> Primary .)
    AND             reduce using rule 45 (Factor -> Primary .)
    ;               reduce using rule 45 (Factor -> Primary .)
    OR              reduce using rule 45 (Factor -> Primary .)
    )               reduce using rule 45 (Factor -> Primary .)


state 46

    (46) Factor -> UnaryOp . Primary
    (49) Primary -> . FLOATLIT
    (50) Primary -> . INTLIT
    (51) Primary -> . ID
    (52) Primary -> . ( Expression )

    FLOATLIT        shift and go to state 47
    INTLIT          shift and go to state 48
    ID              shift and go to state 37
    (               shift and go to state 49

    Primary                        shift and go to state 72

state 47

    (49) Primary -> FLOATLIT .

    *               reduce using rule 49 (Primary -> FLOATLIT .)
    /               reduce using rule 49 (Primary -> FLOATLIT .)
    %               reduce using rule 49 (Primary -> FLOATLIT .)
    <               reduce using rule 49 (Primary -> FLOATLIT .)
    LE              reduce using rule 49 (Primary -> FLOATLIT .)
    >               reduce using rule 49 (Primary -> FLOATLIT .)
    GE              reduce using rule 49 (Primary -> FLOATLIT .)
    +               reduce using rule 49 (Primary -> FLOATLIT .)
    -               reduce using rule 49 (Primary -> FLOATLIT .)
    EQ              reduce using rule 49 (Primary -> FLOATLIT .)
    NEQ             reduce using rule 49 (Primary -> FLOATLIT .)
    AND             reduce using rule 49 (Primary -> FLOATLIT .)
    ;               reduce using rule 49 (Primary -> FLOATLIT .)
    OR              reduce using rule 49 (Primary -> FLOATLIT .)
    )               reduce using rule 49 (Primary -> FLOATLIT .)


state 48

    (50) Primary -> INTLIT .

    *               reduce using rule 50 (Primary -> INTLIT .)
    /               reduce using rule 50 (Primary -> INTLIT .)
    %               reduce using rule 50 (Primary -> INTLIT .)
    <               reduce using rule 50 (Primary -> INTLIT .)
    LE              reduce using rule 50 (Primary -> INTLIT .)
    >               reduce using rule 50 (Primary -> INTLIT .)
    GE              reduce using rule 50 (Primary -> INTLIT .)
    +               reduce using rule 50 (Primary -> INTLIT .)
    -               reduce using rule 50 (Primary -> INTLIT .)
    EQ              reduce using rule 50 (Primary -> INTLIT .)
    NEQ             reduce using rule 50 (Primary -> INTLIT .)
    AND             reduce using rule 50 (Primary -> INTLIT .)
    ;               reduce using rule 50 (Primary -> INTLIT .)
    OR              reduce using rule 50 (Primary -> INTLIT .)
    )               reduce using rule 50 (Primary -> INTLIT .)


state 49

    (52) Primary -> ( . Expression )
    (22) Expression -> . Conjunction
    (23) Expression -> . Expression OR Conjunction
    (24) Conjunction -> . Equality
    (25) Conjunction -> . Conjunction AND Equality
    (26) Equality -> . Relation
    (27) Equality -> . Relation EquOp Relation
    (30) Relation -> . Addition
    (31) Relation -> . Addition RelOp Addition
    (36) Addition -> . Term
    (37) Addition -> . Addition AddOp Term
    (40) Term -> . Factor
    (41) Term -> . Term MulOp Factor
    (45) Factor -> . Primary
    (46) Factor -> . UnaryOp Primary
    (49) Primary -> . FLOATLIT
    (50) Primary -> . INTLIT
    (51) Primary -> . ID
    (52) Primary -> . ( Expression )
    (47) UnaryOp -> . -
    (48) UnaryOp -> . !

    FLOATLIT        shift and go to state 47
    INTLIT          shift and go to state 48
    ID              shift and go to state 37
    (               shift and go to state 49
    -               shift and go to state 50
    !               shift and go to state 51

    Expression                     shift and go to state 73
    Conjunction                    shift and go to state 39
    Equality                       shift and go to state 40
    Relation                       shift and go to state 41
    Addition                       shift and go to state 42
    Term                           shift and go to state 43
    Factor                         shift and go to state 44
    Primary                        shift and go to state 45
    UnaryOp                        shift and go to state 46

state 50

    (47) UnaryOp -> - .

    FLOATLIT        reduce using rule 47 (UnaryOp -> - .)
    INTLIT          reduce using rule 47 (UnaryOp -> - .)
    ID              reduce using rule 47 (UnaryOp -> - .)
    (               reduce using rule 47 (UnaryOp -> - .)


state 51

    (48) UnaryOp -> ! .

    FLOATLIT        reduce using rule 48 (UnaryOp -> ! .)
    INTLIT          reduce using rule 48 (UnaryOp -> ! .)
    ID              reduce using rule 48 (UnaryOp -> ! .)
    (               reduce using rule 48 (UnaryOp -> ! .)


state 52

    (19) IfStatement -> IF ( Expression . ) Statement
    (20) IfStatement -> IF ( Expression . ) Statement ELSE Statement
    (23) Expression -> Expression . OR Conjunction

    )               shift and go to state 74
    OR              shift and go to state 55


state 53

    (21) WhileStatement -> WHILE ( Expression . ) Statement
    (23) Expression -> Expression . OR Conjunction

    )               shift and go to state 75
    OR              shift and go to state 55


state 54

    (18) Assignment -> ID = Expression ; .

    ;               reduce using rule 18 (Assignment -> ID = Expression ; .)
    {               reduce using rule 18 (Assignment -> ID = Expression ; .)
    ID              reduce using rule 18 (Assignment -> ID = Expression ; .)
    IF              reduce using rule 18 (Assignment -> ID = Expression ; .)
    WHILE           reduce using rule 18 (Assignment -> ID = Expression ; .)
    }               reduce using rule 18 (Assignment -> ID = Expression ; .)
    ELSE            reduce using rule 18 (Assignment -> ID = Expression ; .)


state 55

    (23) Expression -> Expression OR . Conjunction
    (24) Conjunction -> . Equality
    (25) Conjunction -> . Conjunction AND Equality
    (26) Equality -> . Relation
    (27) Equality -> . Relation EquOp Relation
    (30) Relation -> . Addition
    (31) Relation -> . Addition RelOp Addition
    (36) Addition -> . Term
    (37) Addition -> . Addition AddOp Term
    (40) Term -> . Factor
    (41) Term -> . Term MulOp Factor
    (45) Factor -> . Primary
    (46) Factor -> . UnaryOp Primary
    (49) Primary -> . FLOATLIT
    (50) Primary -> . INTLIT
    (51) Primary -> . ID
    (52) Primary -> . ( Expression )
    (47) UnaryOp -> . -
    (48) UnaryOp -> . !

    FLOATLIT        shift and go to state 47
    INTLIT          shift and go to state 48
    ID              shift and go to state 37
    (               shift and go to state 49
    -               shift and go to state 50
    !               shift and go to state 51

    Conjunction                    shift and go to state 76
    Equality                       shift and go to state 40
    Relation                       shift and go to state 41
    Addition                       shift and go to state 42
    Term                           shift and go to state 43
    Factor                         shift and go to state 44
    Primary                        shift and go to state 45
    UnaryOp                        shift and go to state 46

state 56

    (25) Conjunction -> Conjunction AND . Equality
    (26) Equality -> . Relation
    (27) Equality -> . Relation EquOp Relation
    (30) Relation -> . Addition
    (31) Relation -> . Addition RelOp Addition
    (36) Addition -> . Term
    (37) Addition -> . Addition AddOp Term
    (40) Term -> . Factor
    (41) Term -> . Term MulOp Factor
    (45) Factor -> . Primary
    (46) Factor -> . UnaryOp Primary
    (49) Primary -> . FLOATLIT
    (50) Primary -> . INTLIT
    (51) Primary -> . ID
    (52) Primary -> . ( Expression )
    (47) UnaryOp -> . -
    (48) UnaryOp -> . !

    FLOATLIT        shift and go to state 47
    INTLIT          shift and go to state 48
    ID              shift and go to state 37
    (               shift and go to state 49
    -               shift and go to state 50
    !               shift and go to state 51

    Equality                       shift and go to state 77
    Relation                       shift and go to state 41
    Addition                       shift and go to state 42
    Term                           shift and go to state 43
    Factor                         shift and go to state 44
    Primary                        shift and go to state 45
    UnaryOp                        shift and go to state 46

state 57

    (27) Equality -> Relation EquOp . Relation
    (30) Relation -> . Addition
    (31) Relation -> . Addition RelOp Addition
    (36) Addition -> . Term
    (37) Addition -> . Addition AddOp Term
    (40) Term -> . Factor
    (41) Term -> . Term MulOp Factor
    (45) Factor -> . Primary
    (46) Factor -> . UnaryOp Primary
    (49) Primary -> . FLOATLIT
    (50) Primary -> . INTLIT
    (51) Primary -> . ID
    (52) Primary -> . ( Expression )
    (47) UnaryOp -> . -
    (48) UnaryOp -> . !

    FLOATLIT        shift and go to state 47
    INTLIT          shift and go to state 48
    ID              shift and go to state 37
    (               shift and go to state 49
    -               shift and go to state 50
    !               shift and go to state 51

    Relation                       shift and go to state 78
    Addition                       shift and go to state 42
    Term                           shift and go to state 43
    Factor                         shift and go to state 44
    Primary                        shift and go to state 45
    UnaryOp                        shift and go to state 46

state 58

    (28) EquOp -> EQ .

    FLOATLIT        reduce using rule 28 (EquOp -> EQ .)
    INTLIT          reduce using rule 28 (EquOp -> EQ .)
    ID              reduce using rule 28 (EquOp -> EQ .)
    (               reduce using rule 28 (EquOp -> EQ .)
    -               reduce using rule 28 (EquOp -> EQ .)
    !               reduce using rule 28 (EquOp -> EQ .)


state 59

    (29) EquOp -> NEQ .

    FLOATLIT        reduce using rule 29 (EquOp -> NEQ .)
    INTLIT          reduce using rule 29 (EquOp -> NEQ .)
    ID              reduce using rule 29 (EquOp -> NEQ .)
    (               reduce using rule 29 (EquOp -> NEQ .)
    -               reduce using rule 29 (EquOp -> NEQ .)
    !               reduce using rule 29 (EquOp -> NEQ .)


state 60

    (31) Relation -> Addition RelOp . Addition
    (36) Addition -> . Term
    (37) Addition -> . Addition AddOp Term
    (40) Term -> . Factor
    (41) Term -> . Term MulOp Factor
    (45) Factor -> . Primary
    (46) Factor -> . UnaryOp Primary
    (49) Primary -> . FLOATLIT
    (50) Primary -> . INTLIT
    (51) Primary -> . ID
    (52) Primary -> . ( Expression )
    (47) UnaryOp -> . -
    (48) UnaryOp -> . !

    FLOATLIT        shift and go to state 47
    INTLIT          shift and go to state 48
    ID              shift and go to state 37
    (               shift and go to state 49
    -               shift and go to state 50
    !               shift and go to state 51

    Addition                       shift and go to state 79
    Term                           shift and go to state 43
    Factor                         shift and go to state 44
    Primary                        shift and go to state 45
    UnaryOp                        shift and go to state 46

state 61

    (37) Addition -> Addition AddOp . Term
    (40) Term -> . Factor
    (41) Term -> . Term MulOp Factor
    (45) Factor -> . Primary
    (46) Factor -> . UnaryOp Primary
    (49) Primary -> . FLOATLIT
    (50) Primary -> . INTLIT
    (51) Primary -> . ID
    (52) Primary -> . ( Expression )
    (47) UnaryOp -> . -
    (48) UnaryOp -> . !

    FLOATLIT        shift and go to state 47
    INTLIT          shift and go to state 48
    ID              shift and go to state 37
    (               shift and go to state 49
    -               shift and go to state 50
    !               shift and go to state 51

    Term                           shift and go to state 80
    Factor                         shift and go to state 44
    Primary                        shift and go to state 45
    UnaryOp                        shift and go to state 46

state 62

    (32) RelOp -> < .

    FLOATLIT        reduce using rule 32 (RelOp -> < .)
    INTLIT          reduce using rule 32 (RelOp -> < .)
    ID              reduce using rule 32 (RelOp -> < .)
    (               reduce using rule 32 (RelOp -> < .)
    -               reduce using rule 32 (RelOp -> < .)
    !               reduce using rule 32 (RelOp -> < .)


state 63

    (33) RelOp -> LE .

    FLOATLIT        reduce using rule 33 (RelOp -> LE .)
    INTLIT          reduce using rule 33 (RelOp -> LE .)
    ID              reduce using rule 33 (RelOp -> LE .)
    (               reduce using rule 33 (RelOp -> LE .)
    -               reduce using rule 33 (RelOp -> LE .)
    !               reduce using rule 33 (RelOp -> LE .)


state 64

    (34) RelOp -> > .

    FLOATLIT        reduce using rule 34 (RelOp -> > .)
    INTLIT          reduce using rule 34 (RelOp -> > .)
    ID              reduce using rule 34 (RelOp -> > .)
    (               reduce using rule 34 (RelOp -> > .)
    -               reduce using rule 34 (RelOp -> > .)
    !               reduce using rule 34 (RelOp -> > .)


state 65

    (35) RelOp -> GE .

    FLOATLIT        reduce using rule 35 (RelOp -> GE .)
    INTLIT          reduce using rule 35 (RelOp -> GE .)
    ID              reduce using rule 35 (RelOp -> GE .)
    (               reduce using rule 35 (RelOp -> GE .)
    -               reduce using rule 35 (RelOp -> GE .)
    !               reduce using rule 35 (RelOp -> GE .)


state 66

    (38) AddOp -> + .

    FLOATLIT        reduce using rule 38 (AddOp -> + .)
    INTLIT          reduce using rule 38 (AddOp -> + .)
    ID              reduce using rule 38 (AddOp -> + .)
    (               reduce using rule 38 (AddOp -> + .)
    -               reduce using rule 38 (AddOp -> + .)
    !               reduce using rule 38 (AddOp -> + .)


state 67

    (39) AddOp -> - .

    FLOATLIT        reduce using rule 39 (AddOp -> - .)
    INTLIT          reduce using rule 39 (AddOp -> - .)
    ID              reduce using rule 39 (AddOp -> - .)
    (               reduce using rule 39 (AddOp -> - .)
    -               reduce using rule 39 (AddOp -> - .)
    !               reduce using rule 39 (AddOp -> - .)


state 68

    (41) Term -> Term MulOp . Factor
    (45) Factor -> . Primary
    (46) Factor -> . UnaryOp Primary
    (49) Primary -> . FLOATLIT
    (50) Primary -> . INTLIT
    (51) Primary -> . ID
    (52) Primary -> . ( Expression )
    (47) UnaryOp -> . -
    (48) UnaryOp -> . !

    FLOATLIT        shift and go to state 47
    INTLIT          shift and go to state 48
    ID              shift and go to state 37
    (               shift and go to state 49
    -               shift and go to state 50
    !               shift and go to state 51

    Factor                         shift and go to state 81
    Primary                        shift and go to state 45
    UnaryOp                        shift and go to state 46

state 69

    (42) MulOp -> * .

    FLOATLIT        reduce using rule 42 (MulOp -> * .)
    INTLIT          reduce using rule 42 (MulOp -> * .)
    ID              reduce using rule 42 (MulOp -> * .)
    (               reduce using rule 42 (MulOp -> * .)
    -               reduce using rule 42 (MulOp -> * .)
    !               reduce using rule 42 (MulOp -> * .)


state 70

    (43) MulOp -> / .

    FLOATLIT        reduce using rule 43 (MulOp -> / .)
    INTLIT          reduce using rule 43 (MulOp -> / .)
    ID              reduce using rule 43 (MulOp -> / .)
    (               reduce using rule 43 (MulOp -> / .)
    -               reduce using rule 43 (MulOp -> / .)
    !               reduce using rule 43 (MulOp -> / .)


state 71

    (44) MulOp -> % .

    FLOATLIT        reduce using rule 44 (MulOp -> % .)
    INTLIT          reduce using rule 44 (MulOp -> % .)
    ID              reduce using rule 44 (MulOp -> % .)
    (               reduce using rule 44 (MulOp -> % .)
    -               reduce using rule 44 (MulOp -> % .)
    !               reduce using rule 44 (MulOp -> % .)


state 72

    (46) Factor -> UnaryOp Primary .

    *               reduce using rule 46 (Factor -> UnaryOp Primary .)
    /               reduce using rule 46 (Factor -> UnaryOp Primary .)
    %               reduce using rule 46 (Factor -> UnaryOp Primary .)
    <               reduce using rule 46 (Factor -> UnaryOp Primary .)
    LE              reduce using rule 46 (Factor -> UnaryOp Primary .)
    >               reduce using rule 46 (Factor -> UnaryOp Primary .)
    GE              reduce using rule 46 (Factor -> UnaryOp Primary .)
    +               reduce using rule 46 (Factor -> UnaryOp Primary .)
    -               reduce using rule 46 (Factor -> UnaryOp Primary .)
    EQ              reduce using rule 46 (Factor -> UnaryOp Primary .)
    NEQ             reduce using rule 46 (Factor -> UnaryOp Primary .)
    AND             reduce using rule 46 (Factor -> UnaryOp Primary .)
    ;               reduce using rule 46 (Factor -> UnaryOp Primary .)
    OR              reduce using rule 46 (Factor -> UnaryOp Primary .)
    )               reduce using rule 46 (Factor -> UnaryOp Primary .)


state 73

    (52) Primary -> ( Expression . )
    (23) Expression -> Expression . OR Conjunction

    )               shift and go to state 82
    OR              shift and go to state 55


state 74

    (19) IfStatement -> IF ( Expression ) . Statement
    (20) IfStatement -> IF ( Expression ) . Statement ELSE Statement
    (12) Statement -> . ;
    (13) Statement -> . Block
    (14) Statement -> . Assignment
    (15) Statement -> . IfStatement
    (16) Statement -> . WhileStatement
    (17) Block -> . { Statements }
    (18) Assignment -> . ID = Expression ;
    (19) IfStatement -> . IF ( Expression ) Statement
    (20) IfStatement -> . IF ( Expression ) Statement ELSE Statement
    (21) WhileStatement -> . WHILE ( Expression ) Statement

    ;               shift and go to state 19
    {               shift and go to state 15
    ID              shift and go to state 24
    IF              shift and go to state 25
    WHILE           shift and go to state 26

    Statement                      shift and go to state 83
    Block                          shift and go to state 20
    Assignment                     shift and go to state 21
    IfStatement                    shift and go to state 22
    WhileStatement                 shift and go to state 23

state 75

    (21) WhileStatement -> WHILE ( Expression ) . Statement
    (12) Statement -> . ;
    (13) Statement -> . Block
    (14) Statement -> . Assignment
    (15) Statement -> . IfStatement
    (16) Statement -> . WhileStatement
    (17) Block -> . { Statements }
    (18) Assignment -> . ID = Expression ;
    (19) IfStatement -> . IF ( Expression ) Statement
    (20) IfStatement -> . IF ( Expression ) Statement ELSE Statement
    (21) WhileStatement -> . WHILE ( Expression ) Statement

    ;               shift and go to state 19
    {               shift and go to state 15
    ID              shift and go to state 24
    IF              shift and go to state 25
    WHILE           shift and go to state 26

    Statement                      shift and go to state 84
    Block                          shift and go to state 20
    Assignment                     shift and go to state 21
    IfStatement                    shift and go to state 22
    WhileStatement                 shift and go to state 23

state 76

    (23) Expression -> Expression OR Conjunction .
    (25) Conjunction -> Conjunction . AND Equality

    ;               reduce using rule 23 (Expression -> Expression OR Conjunction .)
    OR              reduce using rule 23 (Expression -> Expression OR Conjunction .)
    )               reduce using rule 23 (Expression -> Expression OR Conjunction .)
    AND             shift and go to state 56


state 77

    (25) Conjunction -> Conjunction AND Equality .

    AND             reduce using rule 25 (Conjunction -> Conjunction AND Equality .)
    ;               reduce using rule 25 (Conjunction -> Conjunction AND Equality .)
    OR              reduce using rule 25 (Conjunction -> Conjunction AND Equality .)
    )               reduce using rule 25 (Conjunction -> Conjunction AND Equality .)


state 78

    (27) Equality -> Relation EquOp Relation .

    AND             reduce using rule 27 (Equality -> Relation EquOp Relation .)
    ;               reduce using rule 27 (Equality -> Relation EquOp Relation .)
    OR              reduce using rule 27 (Equality -> Relation EquOp Relation .)
    )               reduce using rule 27 (Equality -> Relation EquOp Relation .)


state 79

    (31) Relation -> Addition RelOp Addition .
    (37) Addition -> Addition . AddOp Term
    (38) AddOp -> . +
    (39) AddOp -> . -

    EQ              reduce using rule 31 (Relation -> Addition RelOp Addition .)
    NEQ             reduce using rule 31 (Relation -> Addition RelOp Addition .)
    AND             reduce using rule 31 (Relation -> Addition RelOp Addition .)
    ;               reduce using rule 31 (Relation -> Addition RelOp Addition .)
    OR              reduce using rule 31 (Relation -> Addition RelOp Addition .)
    )               reduce using rule 31 (Relation -> Addition RelOp Addition .)
    +               shift and go to state 66
    -               shift and go to state 67

    AddOp                          shift and go to state 61

state 80

    (37) Addition -> Addition AddOp Term .
    (41) Term -> Term . MulOp Factor
    (42) MulOp -> . *
    (43) MulOp -> . /
    (44) MulOp -> . %

    <               reduce using rule 37 (Addition -> Addition AddOp Term .)
    LE              reduce using rule 37 (Addition -> Addition AddOp Term .)
    >               reduce using rule 37 (Addition -> Addition AddOp Term .)
    GE              reduce using rule 37 (Addition -> Addition AddOp Term .)
    +               reduce using rule 37 (Addition -> Addition AddOp Term .)
    -               reduce using rule 37 (Addition -> Addition AddOp Term .)
    EQ              reduce using rule 37 (Addition -> Addition AddOp Term .)
    NEQ             reduce using rule 37 (Addition -> Addition AddOp Term .)
    AND             reduce using rule 37 (Addition -> Addition AddOp Term .)
    ;               reduce using rule 37 (Addition -> Addition AddOp Term .)
    OR              reduce using rule 37 (Addition -> Addition AddOp Term .)
    )               reduce using rule 37 (Addition -> Addition AddOp Term .)
    *               shift and go to state 69
    /               shift and go to state 70
    %               shift and go to state 71

    MulOp                          shift and go to state 68

state 81

    (41) Term -> Term MulOp Factor .

    *               reduce using rule 41 (Term -> Term MulOp Factor .)
    /               reduce using rule 41 (Term -> Term MulOp Factor .)
    %               reduce using rule 41 (Term -> Term MulOp Factor .)
    <               reduce using rule 41 (Term -> Term MulOp Factor .)
    LE              reduce using rule 41 (Term -> Term MulOp Factor .)
    >               reduce using rule 41 (Term -> Term MulOp Factor .)
    GE              reduce using rule 41 (Term -> Term MulOp Factor .)
    +               reduce using rule 41 (Term -> Term MulOp Factor .)
    -               reduce using rule 41 (Term -> Term MulOp Factor .)
    EQ              reduce using rule 41 (Term -> Term MulOp Factor .)
    NEQ             reduce using rule 41 (Term -> Term MulOp Factor .)
    AND             reduce using rule 41 (Term -> Term MulOp Factor .)
    ;               reduce using rule 41 (Term -> Term MulOp Factor .)
    OR              reduce using rule 41 (Term -> Term MulOp Factor .)
    )               reduce using rule 41 (Term -> Term MulOp Factor .)


state 82

    (52) Primary -> ( Expression ) .

    *               reduce using rule 52 (Primary -> ( Expression ) .)
    /               reduce using rule 52 (Primary -> ( Expression ) .)
    %               reduce using rule 52 (Primary -> ( Expression ) .)
    <               reduce using rule 52 (Primary -> ( Expression ) .)
    LE              reduce using rule 52 (Primary -> ( Expression ) .)
    >               reduce using rule 52 (Primary -> ( Expression ) .)
    GE              reduce using rule 52 (Primary -> ( Expression ) .)
    +               reduce using rule 52 (Primary -> ( Expression ) .)
    -               reduce using rule 52 (Primary -> ( Expression ) .)
    EQ              reduce using rule 52 (Primary -> ( Expression ) .)
    NEQ             reduce using rule 52 (Primary -> ( Expression ) .)
    AND             reduce using rule 52 (Primary -> ( Expression ) .)
    ;               reduce using rule 52 (Primary -> ( Expression ) .)
    OR              reduce using rule 52 (Primary -> ( Expression ) .)
    )               reduce using rule 52 (Primary -> ( Expression ) .)


state 83

    (19) IfStatement -> IF ( Expression ) Statement .
    (20) IfStatement -> IF ( Expression ) Statement . ELSE Statement

  ! shift/reduce conflict for ELSE resolved as shift
    ;               reduce using rule 19 (IfStatement -> IF ( Expression ) Statement .)
    {               reduce using rule 19 (IfStatement -> IF ( Expression ) Statement .)
    ID              reduce using rule 19 (IfStatement -> IF ( Expression ) Statement .)
    IF              reduce using rule 19 (IfStatement -> IF ( Expression ) Statement .)
    WHILE           reduce using rule 19 (IfStatement -> IF ( Expression ) Statement .)
    }               reduce using rule 19 (IfStatement -> IF ( Expression ) Statement .)
    ELSE            shift and go to state 85

  ! ELSE            [ reduce using rule 19 (IfStatement -> IF ( Expression ) Statement .) ]


state 84

    (21) WhileStatement -> WHILE ( Expression ) Statement .

    ;               reduce using rule 21 (WhileStatement -> WHILE ( Expression ) Statement .)
    {               reduce using rule 21 (WhileStatement -> WHILE ( Expression ) Statement .)
    ID              reduce using rule 21 (WhileStatement -> WHILE ( Expression ) Statement .)
    IF              reduce using rule 21 (WhileStatement -> WHILE ( Expression ) Statement .)
    WHILE           reduce using rule 21 (WhileStatement -> WHILE ( Expression ) Statement .)
    }               reduce using rule 21 (WhileStatement -> WHILE ( Expression ) Statement .)
    ELSE            reduce using rule 21 (WhileStatement -> WHILE ( Expression ) Statement .)


state 85

    (20) IfStatement -> IF ( Expression ) Statement ELSE . Statement
    (12) Statement -> . ;
    (13) Statement -> . Block
    (14) Statement -> . Assignment
    (15) Statement -> . IfStatement
    (16) Statement -> . WhileStatement
    (17) Block -> . { Statements }
    (18) Assignment -> . ID = Expression ;
    (19) IfStatement -> . IF ( Expression ) Statement
    (20) IfStatement -> . IF ( Expression ) Statement ELSE Statement
    (21) WhileStatement -> . WHILE ( Expression ) Statement

    ;               shift and go to state 19
    {               shift and go to state 15
    ID              shift and go to state 24
    IF              shift and go to state 25
    WHILE           shift and go to state 26

    Statement                      shift and go to state 86
    Block                          shift and go to state 20
    Assignment                     shift and go to state 21
    IfStatement                    shift and go to state 22
    WhileStatement                 shift and go to state 23

state 86

    (20) IfStatement -> IF ( Expression ) Statement ELSE Statement .

    ;               reduce using rule 20 (IfStatement -> IF ( Expression ) Statement ELSE Statement .)
    {               reduce using rule 20 (IfStatement -> IF ( Expression ) Statement ELSE Statement .)
    ID              reduce using rule 20 (IfStatement -> IF ( Expression ) Statement ELSE Statement .)
    IF              reduce using rule 20 (IfStatement -> IF ( Expression ) Statement ELSE Statement .)
    WHILE           reduce using rule 20 (IfStatement -> IF ( Expression ) Statement ELSE Statement .)
    }               reduce using rule 20 (IfStatement -> IF ( Expression ) Statement ELSE Statement .)
    ELSE            reduce using rule 20 (IfStatement -> IF ( Expression ) Statement ELSE Statement .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ELSE in state 83 resolved as shift
